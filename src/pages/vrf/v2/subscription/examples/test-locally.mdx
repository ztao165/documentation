---
layout: ../../../../../layouts/MainLayout.astro
section: vrf
title: "Local testing using a Mock contract"
metadata:
  description: "Example contract for generating random words using the VRF v2 subscription method on your local blockchain using a mock contract."
---

import VrfCommon from "@features/vrf/v2/common/VrfCommon.astro"
import CodeSample from "@components/CodeSample/CodeSample.astro"

<VrfCommon callout="subscription" />

This guide explains how to test Chainlink VRF v2 on a [Remix IDE](https://remix-ide.readthedocs.io/en/latest/run.html#environment) sandbox blockchain environment. **Note**: You can reuse the same logic on another development environment, such as hardhat or truffle. For example, See the hardhat starter kit [RandomNumberConsuper unit tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberConsumer.spec.js).

## Benefits of local testing

Testing locally using mock contracts saves you time and resources during development. Some of the key benefits include:

1. Faster feedback loop: Immediate feedback on the functionality and correctness of your smart contracts. This helps you quickly identify and fix issues without waiting for transactions to be mined/validated on a testnet.
1. Saving your native testnet tokens: Deploying and interacting with contracts requires paying gas fees. Although testnet native tokens do not have any value associated with them, their supply is limited by public faucets. Using mock contracts locally allows you to test your contracts freely without incurring any expenses.
1. Controlled environment: Local testing allows you to create a controlled environment where you can manipulate various parameters, such as block time and gas prices, to test your smart contracts' function as expected under different conditions.
1. Isolated testing: You can focus on testing individual parts of your contract, ensuring they work as intended before integrating them with other components.
1. Easier debugging: Because local tests run on your machine, you have better control over the debugging process. You can set breakpoints, inspect variables, and step through your code to identify and fix issues.
1. Comprehensive test coverage: You can create test cases to cover all possible scenarios and edge cases.

<CodeSample src="samples/VRF/mock/VRFCoordinatorV2Mock.sol" />

<CodeSample src="samples/VRF/mock/VRFv2Consumer.sol" />
